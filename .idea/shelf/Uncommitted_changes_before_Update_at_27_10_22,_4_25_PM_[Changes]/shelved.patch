Index: contracts/DEX.sol
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>pragma solidity >=0.4.22 <0.9.0;\n\nimport \"../utils/SafeMath.sol\";\nimport \"./ERC20API.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract DEX {\n    using SafeMath for uint256;\n\n    struct Offer {\n        uint256 offer_amount;\n        address offer_maker;\n        uint256 higher_priority;\n        uint256 lower_priority;\n    }\n\n    struct OfferLinkedList {\n        uint256 next_price;\n        // 1. when the buy order comes in, we will be traversing the sell book,\n        //      from low to high: because the buyer is looking for prices as low as possible to buy\n        // 2. when the sell order comes in, we will be traversing the buy book,\n        //      from high to low: because the seller is looking for prices as high as possible to sell.\n        mapping(uint256 => Offer) offer_list;\n        uint256 highest_priority;\n        uint256 lowest_priority;\n        uint256 offer_length;\n    }\n\n    struct Token {\n        address token_contract;\n        mapping(bytes32 => OrderBook) Book;\n    }\n\n    struct OrderBook {\n        mapping(uint256 => OfferLinkedList) prices;\n        uint256 first_price;\n        uint256 last_price;\n        // 1. for the sell order book:\n        //      first_price -> min price\n        //      last_price -> max price\n        // 2. for the buy order book:\n        //      first_price -> max price\n        //      last_price -> min price\n        uint256 number_of_prices;\n    }\n\n    mapping(address => Token) token_list;\n\n    mapping(address => uint256) ether_balance;\n\n    mapping(address => string[]) token_address_list;\n\n    function executeTokenMarket(\n        address _baseToken,\n        address _tokenAddress,\n        uint256 _amount,\n        bytes32  _type\n    ) public returns (bool[] memory){\n        emit loguint256(\"Initial amount: \",_amount);\n        // fulfilled, insufficient token, insufficient buy orders\n        bool[] memory feedback = new bool[](3);\n        feedback[0] = false;\n        feedback[1] = false;\n        feedback[2] = false;\n\n        Token storage selfToken = token_list[_tokenAddress];\n        uint256 remainingAmount = _amount;\n        //question\n        //uint256 currentPrice = selfToken.buy_order_book.highest_priority;\n        //lowest price for buy order, highest price for sell order\n        uint256 currentOffer;\n        //uint256 ethAmount = 0;\n        bytes32 otherType;\n\n        if(equals(_type,\"buy\")){\n            otherType = \"sell\";\n        }else{\n            otherType = \"buy\";\n        }\n        uint256 currentPrice = selfToken.Book[otherType].first_price;\n        emit logString(string(abi.encodePacked(otherType)));\n        emit loguint256(\"Current price: \",currentPrice);\n\n        //IERC20 baseToken = ERC20API(_baseTokenAddress);\n        IERC20 token = IERC20(_tokenAddress);\n        IERC20 baseToken = IERC20(_baseToken);\n\n        //No offer for this token\n        if(selfToken.Book[otherType].number_of_prices == 0){\n            feedback[2] = true;\n            emit logString(\"No offer for this token\");\n            //possible entry for batched execution\n            return feedback;\n        }\n        while(remainingAmount > 0 && !feedback[1] && !feedback[2]){\n            //offerPointer\n            //currentOffer = selfToken.buy_order_book[currentPrice].highest_priority;\n            currentOffer = selfToken.Book[otherType].prices[currentPrice].highest_priority;\n            emit logOffer(selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].offer_amount,\n                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].offer_maker,\n                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].higher_priority,\n                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].lower_priority);\n            while (\n            //question\n                currentOffer <= selfToken.Book[otherType].prices[currentPrice].lowest_priority &&\n                remainingAmount > 0 &&\n                !feedback[1]\n            ) {\n\n                uint256 currentOfferAmount = selfToken.Book[otherType].prices[currentPrice]\n                .offer_list[currentOffer]\n                .offer_amount;\n                emit loguint256(\"Current Offer Amount\", currentOfferAmount);\n\n                if(currentOfferAmount >= remainingAmount){\n                    emit logString(\"currentOfferAmount >= remainingAmount\");\n                    //fully filled\n                    // currentOfferAmount >= remainingAmount\n                    if(equals(_type,\"buy\")){\n                        require(getTokenBalance(msg.sender, _baseToken) >= remainingAmount, \"buyer has insufficient Ether\");\n                        // approve exchange to move token to maker\n                        baseToken.approve(\n                            msg.sender,\n                            remainingAmount\n                        );\n                        emit logAddress(msg.sender);\n                        // send token to maker\n                        baseToken.transferFrom(\n                            msg.sender,\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            remainingAmount\n                        );\n                        // approve exchange to move baseToken to maker\n                        token.approve(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                        // send weth to taker\n                        token.transferFrom(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            msg.sender,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                    }else{\n                        require(getTokenBalance(msg.sender, _tokenAddress) >= remainingAmount, \"seller has insufficient token\");\n                        // approve exchange to move token to maker\n                        token.approve(\n                            msg.sender,\n                            remainingAmount\n                        );\n                        emit logAddress(msg.sender);\n                        // send token to maker\n                        token.transferFrom(\n                            msg.sender,\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            remainingAmount\n                        );\n                        // approve exchange to move baseToken to maker\n                        baseToken.approve(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                        // send weth to taker\n                        baseToken.transferFrom(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            msg.sender,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                    }\n\n                            //question: should combine equal case to other else?\n                            if(currentOfferAmount == remainingAmount){\n                                emit logString(\"currentOfferAmount == remainingAmount\");\n\n                                //removeOrder(_baseToken,_token,_type.equals(\"sell\") ? true : false,currentPrice);\n                                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                                .offer_amount = 0;\n\n                                selfToken.Book[otherType].prices[currentPrice]\n                                .highest_priority = selfToken.Book[otherType].prices[currentPrice]\n                                .offer_list[currentOffer]\n                                .lower_priority;\n\n                                selfToken.Book[otherType].prices[currentPrice].offer_length = selfToken.Book[otherType].prices[currentPrice].offer_length.sub(1);\n\n                                emit loguint256(\"Current Offer Amount\", selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                                    .offer_amount);\n                                emit loguint256(\"Current Offer highest priority\", selfToken.Book[otherType].prices[currentPrice]\n                                    .highest_priority);\n                                emit loguint256(\"Offer length\", selfToken.Book[otherType].prices[currentPrice].offer_length);\n                            }else{\n                                emit logString(\"currentOfferAmount != remainingAmount\");\n                                //keep the order, modify the amount\n                                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                                .offer_amount =\n                                selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].offer_amount\n                                .sub(remainingAmount);\n\n                                emit loguint256(\"Current Offer Amount\", selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                                    .offer_amount);\n                                emit loguint256(\"Current Offer highest priority\", selfToken.Book[otherType].prices[currentPrice]\n                                    .highest_priority);\n                                emit loguint256(\"Offer length\", selfToken.Book[otherType].prices[currentPrice].offer_length);\n                            }\n                            remainingAmount = 0;\n\n\n\n                }else{\n                    emit logString(\"currentOfferAmount < remainingAmount\");\n                    //partially filled\n                    //currentOfferAmount < remainingAmount\n                    if(equals(_type,\"buy\")){\n                        require(getTokenBalance(msg.sender, _baseToken) >= currentOfferAmount, \"buyer has insufficient Ether\");\n\n                        // approve exchange to move token to maker\n                        baseToken.approve(\n                            msg.sender,\n                            currentOfferAmount\n                        );\n                        // send token to maker\n                        baseToken.transferFrom(\n                            msg.sender,\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            currentOfferAmount\n                        );\n                        // approve exchange to move baseToken to maker\n                        token.approve(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                        // send weth to taker\n                        token.transferFrom(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            msg.sender,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                    }else{\n                        require(getTokenBalance(msg.sender, _tokenAddress) >= currentOfferAmount, \"seller has insufficient token\");\n\n                        // approve exchange to move token to maker\n                        token.approve(\n                            msg.sender,\n                            currentOfferAmount\n                        );\n                        // send token to maker\n                        token.transferFrom(\n                            msg.sender,\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            currentOfferAmount\n                        );\n                        // approve exchange to move baseToken to maker\n                        baseToken.approve(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                        // send weth to taker\n                        baseToken.transferFrom(\n                            selfToken.Book[otherType].prices[currentPrice]\n                            .offer_list[currentOffer]\n                            .offer_maker,\n                            msg.sender,\n                            (remainingAmount.mul(currentPrice)).div(1e3)\n                        );\n                    }\n\n                        //msg.sender has enough token on his account\n                        //ethAmount = (currentOfferAmount.mul(currentPrice)).div(1e3);\n\n                        //remove offer\n                        //removeOrder(_baseToken,_token,_type.equals(\"sell\") ? true : false,currentPrice);\n                        selfToken.Book[otherType].prices[currentPrice]\n                        .highest_priority = selfToken.Book[otherType].prices[currentPrice]\n                        .offer_list[currentOffer]\n                        .lower_priority;\n                        selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                        .offer_amount;\n                        selfToken.Book[otherType].prices[currentPrice].offer_length = selfToken.Book[otherType].prices[currentPrice].offer_length.sub(1);\n\n                        emit loguint256(\"Current Offer Amount\", selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]\n                            .offer_amount);\n                        emit loguint256(\"Current Offer highest priority\", selfToken.Book[otherType].prices[currentPrice]\n                            .highest_priority);\n                        emit loguint256(\"Offer length\", selfToken.Book[otherType].prices[currentPrice].offer_length);\n\n                        remainingAmount = remainingAmount.sub(currentOfferAmount);\n\n\n                }\n\n                if (currentOffer == selfToken.Book[otherType].prices[currentPrice].lowest_priority &&\n                    selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].offer_amount == 0\n                ) {\n                    emit logString(\"no more order at this price\");\n                    //no more order at this price\n                    selfToken.Book[otherType].number_of_prices = selfToken.Book[otherType].number_of_prices.sub(1);\n                    selfToken.Book[otherType].prices[currentPrice].offer_length = 0;\n\n                    if (\n                        currentPrice == selfToken.Book[otherType].prices[currentPrice].next_price ||\n                        selfToken.Book[otherType].prices[currentPrice].next_price == 0\n                    ) {\n                        emit logString(\"no more order\");\n                        selfToken.Book[otherType].prices[currentPrice].next_price = 0;\n                        selfToken.Book[otherType].number_of_prices = 0;\n                        selfToken.Book[otherType].first_price = 0;\n                        selfToken.Book[otherType].last_price = 0;\n                        return feedback;\n                    } else {\n                        selfToken.Book[otherType].first_price = selfToken.Book[otherType].prices[currentPrice].next_price;\n                        emit loguint256(\"first price change to next price\", selfToken.Book[otherType].first_price);\n                    }\n                    break;\n                }\n                currentOffer = selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].lower_priority;\n                //这个price的order全没了\n                //return feedback;\n            }\n            currentPrice = selfToken.Book[otherType].first_price;\n            emit loguint256(\"current price updated\", currentPrice);\n\n        }\n        if (remainingAmount == 0) {\n            feedback[0] = true;\n        }\n        //emit MarketResult(feedback[0], feedback[1], feedback[2]);\n        return feedback;\n    }\n    function test(address _token,\n            bool is_sell,\n        uint256 _price,\n        uint256 _amount,\n        address _maker) public {\n    }\n\n    function storeOrder(\n        address _token,\n        bool is_sell,\n        uint256 _price,\n        uint256 _amount,\n        address _maker\n    ) public {\n        bytes32 book_name = \"buy\";\n        if (is_sell) {\n            book_name = \"sell\";\n        }\n        OrderBook storage orderBook = token_list[_token].Book[book_name];\n        orderBook.prices[_price].offer_length = orderBook.prices[_price].offer_length.add(1);\n\n//        emit test(_price);\n        if (orderBook.prices[_price].offer_length == 1) {\n            //If this is the first offer at this price\n            orderBook.prices[_price].highest_priority = 1;\n            orderBook.prices[_price].lowest_priority = 1;\n            orderBook.number_of_prices = orderBook.number_of_prices.add(1);\n\n            orderBook.prices[_price].offer_list[orderBook.prices[_price].offer_length] = Offer(_amount, _maker, 0, 1);\n\n            uint256 firstPrice = orderBook.first_price;\n            uint256 lastPrice = orderBook.last_price;\n\n            if (lastPrice == 0 || is_sell && lastPrice < _price || !is_sell && lastPrice > _price) {\n                //insert this price to the end of the orderbook\n                if (firstPrice == 0) {\n                    //if this is also the first price\n                    orderBook.first_price = _price;\n                    orderBook.prices[_price].next_price = _price;\n                } else {\n                    orderBook.prices[lastPrice]\n                    .next_price = _price;\n                    orderBook.prices[_price].next_price = _price;\n                }\n                orderBook.last_price = _price;\n            } else if (is_sell && firstPrice > _price || !is_sell && firstPrice < _price) {\n                //insert this price to the front of the orderbook\n                orderBook.prices[_price].next_price = firstPrice;\n                orderBook.first_price = _price;\n            } else {\n                //insert this price in the middle of the orderbook\n                uint256 currentPrice = orderBook.first_price;\n                bool inserted = false;\n                while (currentPrice > 0 && !inserted) {\n                    if (\n                        is_sell &&\n                        currentPrice < _price &&\n                        orderBook.prices[currentPrice].next_price > _price\n                        ||\n                        !is_sell &&\n                        currentPrice > _price &&\n                        orderBook.prices[currentPrice].next_price < _price\n                    ) {\n                        orderBook.prices[_price].next_price = orderBook.prices[currentPrice].next_price;\n\n                        orderBook.prices[currentPrice].next_price = _price;\n                        inserted = true;\n                    }\n                    currentPrice = orderBook.prices[currentPrice].next_price;\n                }\n            }\n\n        } else {\n            uint256 currentLowest = orderBook.prices[_price].lowest_priority.add(1);\n            orderBook.prices[_price].offer_list[currentLowest] = Offer(\n                _amount,\n                _maker,\n                orderBook.prices[_price].lowest_priority,\n                currentLowest\n            );\n            orderBook.prices[_price].offer_list[orderBook.prices[_price]\n            .lowest_priority]\n            .lower_priority = currentLowest;\n            orderBook.prices[_price].lowest_priority = currentLowest;\n        }\n    }\n\n    function removeOrder(\n        address _baseToken,\n        address _token,\n        bool is_sell,\n        uint256 _price\n    ) public {\n        bytes32 book_name = \"buy\";\n        if (is_sell) {\n            book_name = \"sell\";\n        }\n        OrderBook storage orderBook = token_list[_token].Book[book_name];\n//        uint256 totalOffers = 0;\n        ERC20API token = ERC20API(_token);\n        ERC20API baseToken = ERC20API(_baseToken);\n        //This function assume this is a valid price\n        // remove all offer_list for this price\n        uint256 counter = orderBook.first_price;\n        bool found = false;\n        if (orderBook.first_price == _price ) found = true;\n        while (counter != orderBook.last_price && !found) {\n            counter = orderBook.prices[counter].next_price;\n            if (counter == _price) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            emit logString(\"found\");\n        }\n        counter = orderBook.prices[_price].highest_priority;\n        while (counter <= orderBook.prices[_price].lowest_priority && found) {\n            if (\n                orderBook.prices[_price].offer_list[counter].offer_maker ==\n                msg.sender\n            ) {\n//                totalOffers = totalOffers.add(1);\n\n                orderBook.prices[_price].offer_length = orderBook.prices[_price]\n                .offer_length\n                .sub(1);\n\n                if (\n                    orderBook.prices[_price].offer_list[counter]\n                    .higher_priority == 0\n                ) {\n                    // if this offer is first in queue\n                    orderBook.prices[_price]\n                    .highest_priority = orderBook.prices[_price]\n                    .offer_list[counter]\n                    .lower_priority;\n                    orderBook.prices[_price].offer_list[orderBook.prices[_price]\n                    .offer_list[counter]\n                    .lower_priority]\n                    .higher_priority = 0;\n                } else if (\n                    orderBook.prices[_price].offer_list[counter]\n                    .lower_priority ==\n                    orderBook.prices[_price].lowest_priority\n                ) {\n                    // if this offer is the last in queue\n                    orderBook.prices[_price]\n                    .lowest_priority = orderBook.prices[_price]\n                    .offer_list[counter]\n                    .higher_priority;\n                    orderBook.prices[_price].offer_list[orderBook.prices[_price]\n                    .offer_list[counter]\n                    .higher_priority]\n                    .lower_priority = orderBook.prices[_price]\n                    .lowest_priority;\n                } else {\n                    //orderBook.prices[_price].offer_list[counter].offer_amount = 0;\n                    // Set lower priority's higher_priority to current higher_priority\n                    orderBook.prices[_price].offer_list[orderBook.prices[_price]\n                    .offer_list[counter]\n                    .lower_priority]\n                    .higher_priority = orderBook.prices[_price]\n                    .offer_list[counter]\n                    .higher_priority;\n                    // Set higher priority's lower_priority to current lower_priority\n                    orderBook.prices[_price].offer_list[orderBook.prices[_price]\n                    .offer_list[counter]\n                    .higher_priority]\n                    .lower_priority = orderBook.prices[_price]\n                    .offer_list[counter]\n                    .lower_priority;\n                }\n            }\n            if (counter == orderBook.prices[_price].lowest_priority) {\n                break;\n            }\n            counter = orderBook.prices[_price].offer_list[counter]\n            .lower_priority;\n        }\n\n        // If offer list is empty, remove the price from price list\n        if (\n            orderBook.prices[_price].offer_length == 0 && found\n//            orderBook.prices[_price].offer_length == 0 && totalOffers > 0\n        ) {\n            if (\n                orderBook.number_of_prices == 1 &&\n                orderBook.first_price == _price\n            ) {\n                // if this is the only price left\n                orderBook.prices[_price].offer_length = 0;\n                orderBook.prices[_price].next_price = 0;\n                orderBook.number_of_prices = 0;\n                orderBook.first_price = 0;\n                orderBook.last_price = 0;\n            } else if (orderBook.first_price == _price) {\n                // if this is the first price in order book list\n                orderBook.first_price = orderBook.prices[_price]\n                .next_price;\n                orderBook.number_of_prices = orderBook\n                .number_of_prices\n                .sub(1);\n            } else {\n                // if we are in between order book list\n                uint256 previousPrice = orderBook.first_price;\n                while (orderBook.prices[previousPrice].next_price != _price) {\n                    previousPrice = orderBook.prices[previousPrice].next_price;\n                }\n                if (_price == orderBook.last_price) {\n                    // if this is the last price in order book list\n                    orderBook.prices[previousPrice].next_price = previousPrice;\n                    orderBook.last_price = previousPrice;\n                } else {\n                    // if we are in between order book list\n                    orderBook.prices[previousPrice].next_price\n                    = orderBook.prices[_price].next_price;\n                }\n                orderBook.number_of_prices = orderBook\n                .number_of_prices\n                .sub(1);\n                // if we are in between order book list\n//                uint256 previousPrice = orderBook.first_price;\n//                while (orderBook.prices[previousPrice].next_price != orderBook.last_price) {\n//                    previousPrice = orderBook.prices[previousPrice].next_price;\n//                    if (orderBook.prices[previousPrice].next_price == _price) break;\n//                }\n//                if (_price == orderBook.last_price) {\n//                    // if this is the last price in order book list\n//                    orderBook.prices[previousPrice].next_price = previousPrice;\n//                    orderBook.last_price = previousPrice;\n//                    orderBook.number_of_prices = orderBook\n//                    .number_of_prices\n//                    .sub(1);\n//                } else if (orderBook.prices[previousPrice].next_price != orderBook.last_price){\n//                    // if we are in between order book list\n//                    orderBook.prices[previousPrice].next_price\n//                    = orderBook.prices[_price].next_price;\n//                    orderBook.number_of_prices = orderBook\n//                    .number_of_prices\n//                    .sub(1);\n//                }\n//                orderBook.number_of_prices = orderBook\n//                .number_of_prices\n//                .sub(1);\n            }\n        }\n    }\n\n    function getOrders(address _token, bool is_sell)\n    public\n    view\n    returns (uint256[] memory, uint256[] memory)\n    {\n        bytes32 book_name = \"buy\";\n        if (is_sell) {\n            book_name = \"sell\";\n        }\n        OrderBook storage orderBook = token_list[_token].Book[book_name];\n\n        uint256 currentPrice = orderBook.first_price;\n        uint256 no_total_offer = 0;\n        //loop the orderBook and increase no_total_offer\n        if (orderBook.first_price > 0) {\n            while (!is_sell && currentPrice <= orderBook.first_price ||\n            is_sell && currentPrice >= orderBook.first_price) {\n                no_total_offer += orderBook.prices[currentPrice].offer_length;\n\n                if (currentPrice == orderBook.prices[currentPrice].next_price) {\n                    break;\n                } else {\n                    currentPrice = orderBook.prices[currentPrice].next_price;\n                }\n            }\n        }\n\n        uint256[] memory ordersPrices = new uint256[](no_total_offer);\n        uint256[] memory ordersVolumes = new uint256[](no_total_offer);\n\n        currentPrice = orderBook.first_price;\n        uint256 counter = 0;\n\n        if (orderBook.first_price > 0) {\n            while (!is_sell && currentPrice <= orderBook.first_price ||\n                    is_sell && currentPrice >= orderBook.first_price) {\n                // uint256 priceVolume = 0;\n                uint256 offerPointer = orderBook.prices[currentPrice].highest_priority;\n\n                while (\n                    offerPointer <= orderBook.prices[currentPrice].lowest_priority\n                ) {\n                    ordersPrices[counter] = currentPrice;\n                    ordersVolumes[counter] = orderBook.prices[currentPrice].offer_list[offerPointer].offer_amount;\n\n                    counter = counter.add(1);\n                    if (offerPointer == orderBook.prices[currentPrice].offer_list[offerPointer].lower_priority){\n                        break;\n                    } else {\n                        offerPointer = orderBook.prices[currentPrice].offer_list[offerPointer].lower_priority;\n                    }\n                }\n\n                if (currentPrice == orderBook.prices[currentPrice].next_price) {\n                    break;\n                } else {\n                    currentPrice = orderBook.prices[currentPrice].next_price;\n                }\n            }\n        }\n\n        return (ordersPrices, ordersVolumes);\n    }\n\n    function executeLimitOrder (\n        address _basicToken,\n        address _token,\n        uint256 _price,\n        uint256 _amount,\n        bool _isBuy\n    ) public {\n\n        Token storage currentToken = token_list[_token]; // find the desired Token object.\n\n        require(\n            getTokenBalance(msg.sender, _basicToken) >= (_price.mul(_amount)).div(1e3),\n            \"executeLimitOrder: the WETH balance < ETH required.\"\n        );\n\n        OrderBook storage orderBook = (_isBuy ? currentToken.Book[\"sell\"]:currentToken.Book[\"buy\"]);\n        // choose the desired order book: buy -> sell order book; sell -> buy order book\n\n        // check if the proposed order price is able to match any order price\n        if (\n            (_isBuy && _price < orderBook.first_price) || // buy order price smaller than minimum sell price\n            (!_isBuy && _price > orderBook.first_price) || // sell order price higher than maximum buy price\n            orderBook.number_of_prices == 0 // there is no order to match.\n        ) storeOrder(_token, !_isBuy, _price, _amount, msg.sender); // store the order and delay its execution\n\n        ERC20API basicToken = ERC20API(_basicToken);\n        ERC20API desiredToken = ERC20API(_token);\n        uint256 totalEtherToTrade = 0;\n        uint256 amountLeftToTrade = _amount;\n        uint256 currentTradePrice = orderBook.first_price;\n        uint256 offerPtr;\n\n        while (currentTradePrice != 0 && amountLeftToTrade > 0){\n            if ((_isBuy && _price < currentTradePrice) || (!_isBuy && _price > currentTradePrice)) {\n                storeOrder(_token, !_isBuy, _price, amountLeftToTrade, msg.sender);\n                break;\n            }\n            offerPtr = orderBook.prices[currentTradePrice].highest_priority; // initiate the helper offer pointer to traverse the price node.\n            while (offerPtr != orderBook.prices[currentTradePrice].lowest_priority\n                && amountLeftToTrade > 0) {\n\n                if (orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount <= amountLeftToTrade){\n                    //this offer cannot fulfill the amount\n\n                    totalEtherToTrade = ((orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount).mul(currentTradePrice)).div(1e3);\n\n                    require(\n                        getTokenBalance(msg.sender, _basicToken) >= totalEtherToTrade,\n                        \"executeLimitOrder: insufficient ether balance.\"\n                    );\n\n                    basicToken.transferFrom(\n                        msg.sender,\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_maker,\n                        totalEtherToTrade\n                    );\n\n                    desiredToken.transferFrom(\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_maker,\n                        msg.sender,\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount\n                    );\n\n                    orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount = 0;\n                    orderBook.prices[currentTradePrice].offer_length = orderBook.prices[currentTradePrice].offer_length.sub(1);\n                    orderBook.prices[currentTradePrice].highest_priority = orderBook.prices[currentTradePrice].offer_list[offerPtr].lower_priority;\n                    amountLeftToTrade = amountLeftToTrade.sub(orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount);\n                    //removeOrder(_basicToken, _token, !_isBuy, currentTradePrice);\n                } else {\n                    //this offer can fulfill the amount\n                    totalEtherToTrade = (amountLeftToTrade.mul(currentTradePrice)).div(1e3);\n\n                    require(\n                        getTokenBalance(msg.sender, _basicToken) >= totalEtherToTrade,\n                        \"executeLimitOrder: insufficient ether balance.\"\n                    );\n\n                    basicToken.transferFrom(\n                        msg.sender,\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_maker,\n                        totalEtherToTrade\n                    );\n\n                    desiredToken.transferFrom(\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_maker,\n                        msg.sender,\n                        amountLeftToTrade\n                    );\n\n                    orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount =\n                        orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount.sub(amountLeftToTrade);\n                    amountLeftToTrade = 0;\n                }\n\n                if (offerPtr == orderBook.prices[currentTradePrice].lowest_priority &&\n                    orderBook.prices[currentTradePrice].offer_list[offerPtr].offer_amount == 0\n                ) {\n                    //if this price has no offer left, remove it from order book\n                    orderBook.number_of_prices = orderBook.number_of_prices.sub(1);\n                    orderBook.prices[currentTradePrice].offer_length = 0;\n\n                    if (\n                        currentTradePrice == orderBook.prices[currentTradePrice].next_price ||\n                        orderBook.prices[currentTradePrice].next_price == 0\n                    ) {\n                        //this price is the only price in the order book\n                        orderBook.prices[currentTradePrice].next_price = 0;\n                        orderBook.number_of_prices = 0;\n                        orderBook.first_price = 0;\n                        orderBook.last_price = 0;\n                    } else {\n                        orderBook.first_price = orderBook.prices[currentTradePrice].next_price;\n                    }\n                    break;\n                }\n                offerPtr = orderBook.prices[currentTradePrice].offer_list[offerPtr].lower_priority;\n            }\n            currentTradePrice = orderBook.first_price;\n        }\n    }\n\n\n\n    function getTokenBalance(address user, address _tokenAddress) public view returns(uint256) {\n        ERC20API tokenLoaded = ERC20API(_tokenAddress);\n        return tokenLoaded.balanceOf(user);\n    }\n\n    //string comparison\n    function equals(bytes32 str1, bytes32 str2) public pure returns(bool) {\n        return (str1 == str2);\n    }\n\n    function test(uint256 numTokens) public returns (bool){\n        return true;\n    }\n\n    function getOrderBookInfo(address _token, bool is_sell) public returns (uint256, uint256, uint256) {\n        bytes32 book_name = \"buy\";\n        if (is_sell) {\n            book_name = \"sell\";\n        }\n        OrderBook storage orderBook = token_list[_token].Book[book_name];\n        uint256 firstPrice = orderBook.first_price;\n        uint256 no_prices = orderBook.number_of_prices;\n        uint256 lastPrice = orderBook.last_price;\n        string memory name = \"buy\";\n        if (is_sell) {\n            name = \"sell\";\n        }\n        emit logOrderBook(name, no_prices, firstPrice, lastPrice);\n        return (no_prices, firstPrice, lastPrice);\n    }\n    function getOffersInfo(address _token, bool is_sell, uint256 _price) public returns (uint256, uint256, uint256, uint256) {\n        bytes32 book_name = \"buy\";\n        if (is_sell) {\n            book_name = \"sell\";\n        }\n        OfferLinkedList storage offers = token_list[_token].Book[book_name].prices[_price];\n        uint256  len = offers.offer_length;\n        uint256 highest_p = offers.highest_priority;\n        uint256 lowest_p = offers.lowest_priority;\n        uint256 next_price = offers.next_price;\n        emit logOfferList(len, highest_p, lowest_p, next_price);\n        return (len, highest_p, lowest_p, next_price);\n    }\n\n    event logBytes32(bytes32 _type);\n    event loguint256(string logMessage, uint256 message);\n    event logOffer(uint256 offer_amount, address offer_maker, uint256 higher_priority, uint256 lower_priority);\n\n    event logAddress(address _address);\n    event loguint256(uint256 message);\n    event logString(string _string);\n    event logOfferList(uint256 no_of_offers, uint256 highest_priority, uint256 lowest_priority, uint256 next_price);\n    event logOrderBook(string book_name, uint256 no_of_prices, uint256 first_price, uint256 last_price);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/contracts/DEX.sol b/contracts/DEX.sol
--- a/contracts/DEX.sol	(revision 008f69877150f8c0bb3aad983338be2cc3d36eb9)
+++ b/contracts/DEX.sol	(date 1666856333722)
@@ -102,18 +102,21 @@
                 selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].higher_priority,
                 selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer].lower_priority);
             while (
-            //question
                 currentOffer <= selfToken.Book[otherType].prices[currentPrice].lowest_priority &&
                 remainingAmount > 0 &&
                 !feedback[1]
             ) {
 
-                uint256 currentOfferAmount = selfToken.Book[otherType].prices[currentPrice]
+//                uint256 currentOfferAmount = selfToken.Book[otherType].prices[currentPrice]
+//                .offer_list[currentOffer]
+//                .offer_amount;
+                emit loguint256("Current Offer Amount", selfToken.Book[otherType].prices[currentPrice]
+                .offer_list[currentOffer]
+                    .offer_amount);
+
+                if(selfToken.Book[otherType].prices[currentPrice]
                 .offer_list[currentOffer]
-                .offer_amount;
-                emit loguint256("Current Offer Amount", currentOfferAmount);
-
-                if(currentOfferAmount >= remainingAmount){
+                .offer_amount >= remainingAmount){
                     emit logString("currentOfferAmount >= remainingAmount");
                     //fully filled
                     // currentOfferAmount >= remainingAmount
@@ -182,7 +185,9 @@
                     }
 
                             //question: should combine equal case to other else?
-                            if(currentOfferAmount == remainingAmount){
+                            if(selfToken.Book[otherType].prices[currentPrice]
+                            .offer_list[currentOffer]
+                            .offer_amount == remainingAmount){
                                 emit logString("currentOfferAmount == remainingAmount");
 
                                 //removeOrder(_baseToken,_token,_type.equals("sell") ? true : false,currentPrice);
@@ -224,12 +229,16 @@
                     //partially filled
                     //currentOfferAmount < remainingAmount
                     if(equals(_type,"buy")){
-                        require(getTokenBalance(msg.sender, _baseToken) >= currentOfferAmount, "buyer has insufficient Ether");
+                        require(getTokenBalance(msg.sender, _baseToken) >= selfToken.Book[otherType].prices[currentPrice]
+                        .offer_list[currentOffer]
+                        .offer_amount, "buyer has insufficient Ether");
 
                         // approve exchange to move token to maker
                         baseToken.approve(
                             msg.sender,
-                            currentOfferAmount
+                                selfToken.Book[otherType].prices[currentPrice]
+                                .offer_list[currentOffer]
+                                .offer_amount
                         );
                         // send token to maker
                         baseToken.transferFrom(
@@ -237,7 +246,9 @@
                             selfToken.Book[otherType].prices[currentPrice]
                             .offer_list[currentOffer]
                             .offer_maker,
-                            currentOfferAmount
+                                selfToken.Book[otherType].prices[currentPrice]
+                                .offer_list[currentOffer]
+                                .offer_amount
                         );
                         // approve exchange to move baseToken to maker
                         token.approve(
@@ -255,12 +266,16 @@
                             (remainingAmount.mul(currentPrice)).div(1e3)
                         );
                     }else{
-                        require(getTokenBalance(msg.sender, _tokenAddress) >= currentOfferAmount, "seller has insufficient token");
+                        require(getTokenBalance(msg.sender, _tokenAddress) >= selfToken.Book[otherType].prices[currentPrice]
+                        .offer_list[currentOffer]
+                        .offer_amount, "seller has insufficient token");
 
                         // approve exchange to move token to maker
                         token.approve(
                             msg.sender,
-                            currentOfferAmount
+                                selfToken.Book[otherType].prices[currentPrice]
+                                .offer_list[currentOffer]
+                                .offer_amount
                         );
                         // send token to maker
                         token.transferFrom(
@@ -268,7 +283,9 @@
                             selfToken.Book[otherType].prices[currentPrice]
                             .offer_list[currentOffer]
                             .offer_maker,
-                            currentOfferAmount
+                                selfToken.Book[otherType].prices[currentPrice]
+                                .offer_list[currentOffer]
+                                .offer_amount
                         );
                         // approve exchange to move baseToken to maker
                         baseToken.approve(
@@ -292,12 +309,15 @@
 
                         //remove offer
                         //removeOrder(_baseToken,_token,_type.equals("sell") ? true : false,currentPrice);
+                        remainingAmount = remainingAmount.sub(selfToken.Book[otherType].prices[currentPrice]
+                        .offer_list[currentOffer]
+                            .offer_amount);
                         selfToken.Book[otherType].prices[currentPrice]
                         .highest_priority = selfToken.Book[otherType].prices[currentPrice]
                         .offer_list[currentOffer]
                         .lower_priority;
                         selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]
-                        .offer_amount;
+                        .offer_amount = 0;
                         selfToken.Book[otherType].prices[currentPrice].offer_length = selfToken.Book[otherType].prices[currentPrice].offer_length.sub(1);
 
                         emit loguint256("Current Offer Amount", selfToken.Book[otherType].prices[currentPrice].offer_list[currentOffer]
@@ -306,7 +326,7 @@
                             .highest_priority);
                         emit loguint256("Offer length", selfToken.Book[otherType].prices[currentPrice].offer_length);
 
-                        remainingAmount = remainingAmount.sub(currentOfferAmount);
+
 
 
                 }
